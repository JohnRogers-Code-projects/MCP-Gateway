<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>MCP Demo Dashboard</title>
    <link rel="stylesheet" href="/static/css/dashboard.css">
    <!-- Alpine.js - lightweight reactivity, no build step -->
    <script defer src="https://cdn.jsdelivr.net/npm/alpinejs@3.x.x/dist/cdn.min.js"></script>
    <!-- Chart.js for benchmark visualization -->
    <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.1/dist/chart.umd.min.js"></script>
    <script src="/static/js/dashboard.js"></script>
</head>
<body>
    <div class="container" x-data="dashboard">
        <header>
            <h1>MCP Protocol Demo</h1>
            <p><span data-tooltip="Converts traditional web API calls into a format that AI assistants can understand and use">REST-to-MCP adapter</span> demonstrating <span data-tooltip="Taking requests in one format and converting them to another format that a different system expects">protocol translation</span> for <span data-tooltip="Giving AI models like Claude or GPT the ability to take actions, like fetching data or creating records">LLM tool integration</span></p>
        </header>

        <!-- Navigation Tabs -->
        <nav class="tabs">
            <button class="tab" :class="{ active: activeTab === 'demo' }" @click="activeTab = 'demo'">
                Interactive Demo
            </button>
            <button class="tab" :class="{ active: activeTab === 'playground' }" @click="activeTab = 'playground'">
                Agent Playground
            </button>
            <button class="tab" :class="{ active: activeTab === 'benchmarks' }" @click="activeTab = 'benchmarks'">
                Benchmarks
            </button>
            <button class="tab" :class="{ active: activeTab === 'docs' }" @click="activeTab = 'docs'">
                Documentation
            </button>
            <button class="tab" :class="{ active: activeTab === 'tests' }" @click="activeTab = 'tests'">
                Test Runner
            </button>
        </nav>

        <!-- Interactive Demo Panel -->
        <div class="panel" :class="{ active: activeTab === 'demo' }">
            <div class="grid-2">
                <!-- Request Builder -->
                <div class="card">
                    <h2>MCP Request Builder</h2>

                    <div class="form-group">
                        <label for="method"><span data-tooltip="The action you want the server to perform. Like choosing a command from a menu.">Method</span></label>
                        <select id="method" x-model="selectedMethod">
                            <option value="tools/list">tools/list - Discover available tools</option>
                            <option value="tools/call">tools/call - Execute a tool</option>
                            <option value="initialize">initialize - Handshake (info only)</option>
                        </select>
                    </div>

                    <div class="form-group">
                        <label for="params"><span data-tooltip="Extra information the method needs to do its job. For example, which tool to run and what data to give it.">Parameters (JSON)</span></label>
                        <textarea id="params" x-model="requestParams" rows="8"></textarea>
                    </div>

                    <button class="btn btn-primary" @click="sendRequest" :disabled="isLoading">
                        <span x-show="!isLoading">Send Request</span>
                        <span x-show="isLoading"><span class="spinner"></span> Sending...</span>
                    </button>

                    <!-- Quick Examples -->
                    <h3>Quick Examples</h3>
                    <div class="grid-3">
                        <template x-for="example in examples" :key="example.name">
                            <div class="example-card" @click="loadExample(example)">
                                <h4 x-text="example.name"></h4>
                                <p x-text="example.description"></p>
                            </div>
                        </template>
                    </div>
                </div>

                <!-- Response Viewer -->
                <div class="card">
                    <h2>Response</h2>

                    <!-- Request Preview -->
                    <h3><span data-tooltip="This is the exact message being sent to the server. It follows JSON-RPC format: a standard way for programs to talk to each other.">Request Sent</span></h3>
                    <pre><code x-text="formatJson(buildRequest())"></code></pre>

                    <!-- Response -->
                    <div class="response-section">
                        <div class="response-header">
                            <h3>Server Response</h3>
                            <span class="response-time" x-show="responseTime" data-tooltip="Round-trip time: how long from sending the request until receiving the response. Lower is faster.">
                                <span x-text="responseTime"></span>ms
                            </span>
                        </div>

                        <!-- Loading state -->
                        <template x-if="isLoading">
                            <div style="text-align: center; padding: 2rem;">
                                <span class="spinner" style="width: 24px; height: 24px;"></span>
                            </div>
                        </template>

                        <!-- Error state -->
                        <template x-if="error && !isLoading">
                            <div>
                                <span class="status status-error">Error</span>
                                <pre style="margin-top: 0.75rem;"><code x-text="formatJson(error)"></code></pre>
                            </div>
                        </template>

                        <!-- Success state -->
                        <template x-if="response && !isLoading">
                            <div>
                                <span class="status status-success">Success</span>
                                <pre style="margin-top: 0.75rem;"><code x-text="formatJson(response)"></code></pre>
                            </div>
                        </template>

                        <!-- Empty state -->
                        <template x-if="!response && !error && !isLoading">
                            <p style="color: var(--text-secondary); font-size: 0.9rem;">
                                Send a request to see the response here.
                            </p>
                        </template>
                    </div>
                </div>
            </div>
        </div>

        <!-- Documentation Panel -->
        <div class="panel" :class="{ active: activeTab === 'docs' }">
            <div class="card">
                <h2>Architecture Overview</h2>
                <div class="architecture-flow">
                    <div class="arch-box">
                        <h4>LLM Agent</h4>
                        <p>Claude, GPT, etc.</p>
                    </div>
                    <span class="arch-arrow">→</span>
                    <div class="arch-box highlight">
                        <h4>MCP Adapter</h4>
                        <p>This service</p>
                    </div>
                    <span class="arch-arrow">→</span>
                    <div class="arch-box">
                        <h4>REST API</h4>
                        <p>JSONPlaceholder</p>
                    </div>
                </div>
                <p style="text-align: center; color: var(--text-secondary); margin-top: 1rem;">
                    The adapter translates MCP tool calls into REST requests, enabling LLMs to interact with any REST API.
                </p>
            </div>

            <div class="grid-2">
                <div class="card">
                    <h2>Core Concepts</h2>

                    <div class="concept">
                        <h3>What is MCP?</h3>
                        <p>
                            Model Context Protocol (MCP) is Anthropic's standard for LLM-to-tool communication.
                            It defines how AI models discover and invoke external tools via JSON-RPC 2.0 messages.
                        </p>
                    </div>

                    <div class="concept">
                        <h3>Why Protocol Translation?</h3>
                        <p>
                            Most existing APIs are REST-based. Rather than rewriting them, this adapter
                            dynamically exposes REST endpoints as MCP-compliant tools. The LLM sees a
                            consistent interface regardless of the underlying API.
                        </p>
                    </div>

                    <div class="concept">
                        <h3>Tool Discovery</h3>
                        <p>
                            <code>tools/list</code> returns available tools with their names, descriptions,
                            and parameter schemas. LLMs use this to understand what actions are possible.
                        </p>
                    </div>

                    <div class="concept">
                        <h3>Tool Execution</h3>
                        <p>
                            <code>tools/call</code> invokes a tool by name with arguments. The adapter
                            maps this to the appropriate REST endpoint, makes the HTTP call, and returns
                            the result in MCP format.
                        </p>
                    </div>
                </div>

                <div class="card">
                    <h2>Technical Decisions</h2>

                    <div class="concept">
                        <h3>FastAPI + Pydantic</h3>
                        <p>
                            ASGI server with automatic OpenAPI docs and runtime type validation.
                            Matches the async patterns used in production MCP gateways.
                        </p>
                    </div>

                    <div class="concept">
                        <h3>Rust Parser (PyO3)</h3>
                        <p>
                            JSON-RPC parsing is a hot path in high-throughput gateways. The Rust parser
                            provides ~2M ops/sec with zero GC pauses. PyO3 bindings make it callable from Python.
                        </p>
                    </div>

                    <div class="concept">
                        <h3>JSON-RPC 2.0 Wire Format</h3>
                        <p>
                            Every MCP message is a JSON-RPC envelope with <code>jsonrpc</code>, <code>id</code>,
                            <code>method</code>, and optional <code>params</code>. Responses include
                            <code>result</code> or <code>error</code>.
                        </p>
                    </div>

                    <div class="concept">
                        <h3>Stateless Adapter</h3>
                        <p>
                            No session state between requests. Each tool call is independent, making
                            horizontal scaling trivial. Authentication would be handled per-request.
                        </p>
                    </div>
                </div>
            </div>

            <div class="card">
                <h2>Example Message Flow</h2>
                <div class="grid-2">
                    <div>
                        <h3>1. Client Request (tools/call)</h3>
                        <pre><code>{
  "jsonrpc": "2.0",
  "id": 1,
  "method": "tools/call",
  "params": {
    "name": "get_post",
    "arguments": { "id": 1 }
  }
}</code></pre>
                    </div>
                    <div>
                        <h3>2. Adapter Action</h3>
                        <pre><code>// Adapter maps tool call to REST:
GET https://jsonplaceholder.typicode.com/posts/1

// Headers, auth, etc. handled internally</code></pre>
                    </div>
                    <div>
                        <h3>3. REST API Response</h3>
                        <pre><code>{
  "userId": 1,
  "id": 1,
  "title": "sunt aut facere...",
  "body": "quia et suscipit..."
}</code></pre>
                    </div>
                    <div>
                        <h3>4. MCP Response to Client</h3>
                        <pre><code>{
  "jsonrpc": "2.0",
  "id": 1,
  "result": {
    "content": [
      { "type": "text", "text": "{...}" }
    ]
  }
}</code></pre>
                    </div>
                </div>
            </div>
        </div>

        <!-- Test Runner Panel -->
        <div class="panel" :class="{ active: activeTab === 'tests' }">
            <div class="card">
                <h2>Test Suite Runner</h2>
                <p style="color: var(--text-secondary); margin-bottom: 1rem;">
                    Run the full test suite with live streaming output. Tests cover models, adapter logic,
                    and end-to-end integration with the JSONPlaceholder API.
                </p>

                <button class="btn btn-primary" @click="runTests" :disabled="testsRunning">
                    <span x-show="!testsRunning">Run All Tests</span>
                    <span x-show="testsRunning"><span class="spinner"></span> Running...</span>
                </button>

                <div style="margin-top: 1.5rem;">
                    <div class="response-header">
                        <h3>Output</h3>
                        <div>
                            <span class="status status-pending" x-show="testsRunning">Running</span>
                            <span class="status status-success" x-show="!testsRunning && testOutput.includes('passed')">Complete</span>
                        </div>
                    </div>
                    <div id="test-output" class="test-output" x-html="testOutput || 'Click Run All Tests to execute the test suite.'"></div>
                </div>
            </div>

            <div class="card">
                <h2>Test Coverage</h2>
                <div class="grid-3">
                    <div class="example-card" style="cursor: default;">
                        <h4>Unit Tests</h4>
                        <p>Pydantic models, JSON-RPC serialization, tool schema generation</p>
                    </div>
                    <div class="example-card" style="cursor: default;">
                        <h4>Adapter Tests</h4>
                        <p>REST-to-MCP translation, error handling, parameter mapping</p>
                    </div>
                    <div class="example-card" style="cursor: default;">
                        <h4>Integration Tests</h4>
                        <p>End-to-end flows against live JSONPlaceholder API</p>
                    </div>
                </div>
            </div>
        </div>

        <!-- Benchmarks Panel -->
        <div class="panel" :class="{ active: activeTab === 'benchmarks' }">
            <div class="card">
                <h2>Parser Performance Comparison</h2>
                <p style="color: var(--text-secondary); margin-bottom: 1rem;">
                    JSON-RPC parsing is a hot path in MCP gateways handling thousands of requests per second.
                    This benchmark compares Python (json.loads + Pydantic validation) against a Rust parser
                    (serde_json with PyO3 bindings). Rust eliminates GC pauses and provides predictable latency,
                    making it ideal for high-throughput message parsing.
                </p>

                <div class="benchmark-controls">
                    <div class="form-group">
                        <label><span data-tooltip="The size and complexity of the test message. Larger messages take longer to parse, showing how performance scales.">Payload Type</span></label>
                        <select x-model="benchmarkPayload">
                            <option value="simple">Simple Request (44 bytes)</option>
                            <option value="complex">Complex Request (200+ bytes)</option>
                        </select>
                    </div>

                    <div class="form-group">
                        <label><span data-tooltip="How many times to run the test. More iterations give more accurate averages but take longer.">Iterations</span></label>
                        <select x-model="benchmarkIterations">
                            <option value="1000">1,000 (quick)</option>
                            <option value="10000">10,000 (standard)</option>
                            <option value="100000">100,000 (thorough)</option>
                        </select>
                    </div>

                    <button class="btn btn-primary" @click="runBenchmark" :disabled="benchmarkRunning">
                        <span x-show="!benchmarkRunning">Run Benchmark</span>
                        <span x-show="benchmarkRunning"><span class="spinner"></span> Running...</span>
                    </button>
                </div>

                <!-- Status message -->
                <div x-show="benchmarkStatus" class="benchmark-status" x-text="benchmarkStatus"></div>

                <!-- Rust not available warning -->
                <div x-show="benchmarkComplete && !rustAvailable" class="rust-warning">
                    <strong>Rust parser not available.</strong>
                    <p>Install Rust and run: <code>cd mcp-demo/rust/mcp_parser && maturin develop --release</code></p>
                </div>

                <!-- Results -->
                <div x-show="benchmarkResults.length > 0" class="benchmark-results">
                    <div class="grid-2">
                        <div>
                            <h3><span data-tooltip="How many messages can be parsed per second. Higher is better. This measures raw throughput.">Operations per Second</span></h3>
                            <canvas id="opsChart"></canvas>
                        </div>
                        <div>
                            <h3><span data-tooltip="How long each parse takes in nanoseconds. P50 is the median, P95/P99 show worst-case times. Lower and more consistent is better.">Latency Distribution (ns)</span></h3>
                            <canvas id="latencyChart"></canvas>
                        </div>
                    </div>

                    <!-- Speedup callout -->
                    <div x-show="speedupFactor" class="speedup-callout">
                        <span class="speedup-value" x-text="speedupFactor + 'x'"></span>
                        <span>faster with Rust parser</span>
                    </div>

                    <!-- Raw numbers table -->
                    <h3 style="margin-top: 2rem;">Raw Results</h3>
                    <table class="benchmark-table">
                        <thead>
                            <tr>
                                <th>Parser</th>
                                <th><span data-tooltip="Operations per second - how many parses completed in one second">Ops/sec</span></th>
                                <th><span data-tooltip="Average time per operation in nanoseconds (billionths of a second)">Mean (ns)</span></th>
                                <th><span data-tooltip="50th percentile - half of operations were faster than this">P50 (ns)</span></th>
                                <th><span data-tooltip="95th percentile - 95% of operations were faster than this">P95 (ns)</span></th>
                                <th><span data-tooltip="99th percentile - only 1% of operations were slower than this (worst case)">P99 (ns)</span></th>
                            </tr>
                        </thead>
                        <tbody>
                            <template x-for="result in benchmarkResults" :key="result.parser">
                                <tr>
                                    <td x-text="result.parser"></td>
                                    <td x-text="formatNumber(result.ops_per_sec)"></td>
                                    <td x-text="formatNumber(result.mean_ns)"></td>
                                    <td x-text="formatNumber(result.p50_ns)"></td>
                                    <td x-text="formatNumber(result.p95_ns)"></td>
                                    <td x-text="formatNumber(result.p99_ns)"></td>
                                </tr>
                            </template>
                        </tbody>
                    </table>
                </div>
            </div>

            <!-- Methodology explanation -->
            <div class="card">
                <h2>Methodology</h2>
                <div class="grid-2">
                    <div class="concept">
                        <h3>Python Implementation</h3>
                        <p>
                            <code>json.loads()</code> for parsing + Pydantic model instantiation for validation.
                            This is what the current adapter uses. Standard library + popular validation.
                        </p>
                    </div>
                    <div class="concept">
                        <h3>Rust Implementation</h3>
                        <p>
                            <code>serde_json</code> for parsing + custom validation logic.
                            Called via PyO3 bindings with minimal Python overhead. Zero-copy where possible.
                        </p>
                    </div>
                </div>
                <div class="concept" style="margin-top: 1rem;">
                    <h3>Fair Comparison</h3>
                    <p>
                        Both implementations parse identical payloads. Timing uses <code>time.perf_counter_ns()</code>
                        with warm-up iterations discarded. Statistics include mean, standard deviation, and percentiles.
                    </p>
                </div>
            </div>
        </div>

        <!-- Agent Playground Panel -->
        <div class="panel" :class="{ active: activeTab === 'playground' }">
            <div class="card">
                <h2>Agent Playground</h2>
                <p style="color: var(--text-secondary); margin-bottom: 1rem;">
                    Type a natural language query and watch <span data-tooltip="Actions the AI can take, like 'get_user' or 'create_post'. Each tool maps to a specific API call.">MCP tools</span> execute step-by-step.
                    No LLM required &mdash; this demonstrates how an <span data-tooltip="An AI system that breaks down a task into steps and calls the right tools in sequence to accomplish it">agent</span> would <span data-tooltip="Choosing which tools to call and in what order, passing data between them to complete a task">orchestrate</span> multiple tools.
                </p>

                <div class="form-group">
                    <label>Your Query</label>
                    <input
                        type="text"
                        x-model="playgroundInput"
                        @keydown.enter="runPlayground"
                        placeholder="e.g., Get all posts by user 1 and their comments"
                        class="playground-input"
                    >
                </div>

                <div style="display: flex; gap: 0.5rem; margin-bottom: 1rem;">
                    <button class="btn btn-primary" @click="runPlayground" :disabled="playgroundRunning || !playgroundInput.trim()">
                        <span x-show="!playgroundRunning">Execute</span>
                        <span x-show="playgroundRunning"><span class="spinner"></span> Running...</span>
                    </button>
                    <button class="btn btn-secondary" @click="clearPlayground">Clear</button>
                </div>

                <!-- Example queries -->
                <div class="example-queries">
                    <span style="color: var(--text-secondary); font-size: 0.85rem;">Try:</span>
                    <template x-for="example in playgroundExamples" :key="example">
                        <button class="example-pill" @click="playgroundInput = example">
                            <span x-text="example"></span>
                        </button>
                    </template>
                </div>
            </div>

            <!-- Execution trace -->
            <div class="card" x-show="playgroundSteps.length > 0 || playgroundError">
                <h2><span data-tooltip="A step-by-step log showing each tool called, what data was sent, and what came back. This is exactly what an AI agent would do behind the scenes.">Execution Trace</span></h2>

                <!-- Error state -->
                <div x-show="playgroundError" class="playground-error">
                    <span class="status status-error">Error</span>
                    <p x-text="playgroundError"></p>
                </div>

                <!-- Scenario info -->
                <div x-show="playgroundScenario" class="scenario-header">
                    <span class="status status-success" x-show="playgroundComplete">Complete</span>
                    <span class="status status-pending" x-show="!playgroundComplete && playgroundRunning">Running</span>
                    <span x-text="playgroundScenario"></span>
                </div>

                <!-- Step-by-step trace -->
                <div class="execution-steps">
                    <template x-for="(step, index) in playgroundSteps" :key="index">
                        <div class="execution-step" :class="{ 'step-complete': step.complete, 'step-active': step.active }">
                            <div class="step-header">
                                <span class="step-number" x-text="index + 1"></span>
                                <span class="step-tool" x-text="step.tool"></span>
                                <span class="step-label" x-text="step.label"></span>
                                <span class="spinner" x-show="step.active && !step.complete" style="width: 16px; height: 16px;"></span>
                                <span class="step-check" x-show="step.complete">&#10003;</span>
                            </div>

                            <!-- Tool call details (expandable) -->
                            <div class="step-details" x-show="step.args || step.result">
                                <div x-show="step.args" class="step-section">
                                    <strong><span data-tooltip="The input data sent to this tool - like telling it which user ID to look up">Arguments:</span></strong>
                                    <pre><code x-text="formatJson(step.args)"></code></pre>
                                </div>
                                <div x-show="step.result" class="step-section">
                                    <strong><span data-tooltip="What the tool returned - the actual data fetched from the API">Result:</span></strong>
                                    <pre><code x-text="truncateResult(step.result)"></code></pre>
                                </div>
                            </div>
                        </div>
                    </template>
                </div>

                <!-- Final summary -->
                <div x-show="playgroundSummary" class="playground-summary">
                    <h3>Summary</h3>
                    <p x-text="playgroundSummary"></p>
                </div>
            </div>
        </div>

        <footer style="margin-top: 3rem; padding-top: 1.5rem; border-top: 1px solid var(--border); color: var(--text-secondary); font-size: 0.85rem;">
            <p>
                MCP Demo &mdash; Portfolio project demonstrating REST-to-MCP protocol translation.
                <a href="https://github.com/RogersJohn/MCP-Demo" style="color: var(--accent);">View on GitHub</a>
            </p>
        </footer>
    </div>
</body>
</html>
